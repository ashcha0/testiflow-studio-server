# 视频生成流程开发建议

您好！根据您的需求，我将为您提供一个完整的视频生成流程方案，包括文案转语音、关键词检索媒资和视频拼接。

## 整体流程设计

1. 文案转语音（TTS）
2. 脚本关键词提取与媒资检索
3. 视频素材拼接
4. 语音与视频合成

## 具体实现方案

### 1. 文案转语音（TTS）

可以使用以下几种方式实现文案转语音：

```python:d:\14730\Desktop\GitProject\testiflow-studio\testiflow-studio-server\src\audio_generator\tts_generator.py
import os
from typing import Optional
import edge_tts  # 使用Edge TTS，免费且效果不错
import asyncio

async def generate_speech(
    text: str, 
    output_path: str = "output_speech.mp3", 
    voice: str = "zh-CN-XiaoxiaoNeural"
) -> str:
    """
    将文本转换为语音文件
    
    参数：
        text (str): 需要转换的文本
        output_path (str): 输出的音频文件路径
        voice (str): 语音角色，默认为微软小晓
        
    返回：
        str: 生成的音频文件的绝对路径
    """
    try:
        communicate = edge_tts.Communicate(text, voice)
        await communicate.save(output_path)
        print(f"语音生成成功，保存至 {output_path}")
        return os.path.abspath(output_path)
    except Exception as e:
        print(f"语音生成失败: {str(e)}")
        raise

def tts_generate(text: str, output_path: Optional[str] = None) -> str:
    """
    同步调用TTS生成函数的包装器
    """
    if output_path is None:
        output_path = "output_speech.mp3"
    return asyncio.run(generate_speech(text, output_path))
```

### 2. 关键词提取与媒资检索

```python:d:\14730\Desktop\GitProject\testiflow-studio\testiflow-studio-server\src\media_search\keyword_extractor.py
import jieba.analyse
from typing import List, Dict, Any
import os
import json
import glob

def extract_keywords(script: str, top_n: int = 5) -> List[str]:
    """
    从脚本中提取关键词
    
    参数：
        script (str): 脚本文本
        top_n (int): 提取的关键词数量
        
    返回：
        List[str]: 关键词列表
    """
    # 使用jieba提取关键词
    keywords = jieba.analyse.extract_tags(script, topK=top_n)
    return keywords

def search_media_by_keywords(
    keywords: List[str], 
    media_library_path: str = "d:\\14730\\Desktop\\GitProject\\testiflow-studio\\media_library",
    metadata_file: str = "metadata.json"
) -> List[str]:
    """
    根据关键词在媒资库中检索相关视频
    
    参数：
        keywords (List[str]): 关键词列表
        media_library_path (str): 媒资库路径
        metadata_file (str): 媒资元数据文件
        
    返回：
        List[str]: 匹配的视频文件路径列表
    """
    # 加载媒资库元数据
    metadata_path = os.path.join(media_library_path, metadata_file)
    if os.path.exists(metadata_path):
        with open(metadata_path, 'r', encoding='utf-8') as f:
            metadata = json.load(f)
    else:
        # 如果没有元数据文件，则创建一个简单的索引
        metadata = index_media_library(media_library_path, metadata_file)
    
    # 搜索匹配的视频
    matched_videos = []
    for keyword in keywords:
        for item in metadata:
            if keyword.lower() in item['tags'] or keyword.lower() in item['description'].lower():
                if item['path'] not in matched_videos:
                    matched_videos.append(item['path'])
    
    # 如果没有找到匹配的视频，返回一些默认视频
    if not matched_videos:
        default_videos = glob.glob(os.path.join(media_library_path, "default", "*.mp4"))
        return default_videos
    
    return matched_videos

def index_media_library(
    media_library_path: str, 
    metadata_file: str = "metadata.json"
) -> List[Dict[str, Any]]:
    """
    索引媒资库中的视频文件并创建元数据
    
    参数：
        media_library_path (str): 媒资库路径
        metadata_file (str): 元数据文件名
        
    返回：
        List[Dict[str, Any]]: 媒资库元数据
    """
    metadata = []
    video_extensions = ['.mp4', '.avi', '.mov', '.mkv']
    
    # 遍历媒资库目录
    for root, _, files in os.walk(media_library_path):
        for file in files:
            if any(file.lower().endswith(ext) for ext in video_extensions):
                file_path = os.path.join(root, file)
                # 从文件名和目录结构提取标签和描述
                relative_path = os.path.relpath(root, media_library_path)
                tags = relative_path.split(os.sep) + [os.path.splitext(file)[0]]
                tags = [tag.lower() for tag in tags if tag]
                
                metadata.append({
                    'path': file_path,
                    'tags': tags,
                    'description': ' '.join(tags)
                })
    
    # 保存元数据
    with open(os.path.join(media_library_path, metadata_file), 'w', encoding='utf-8') as f:
        json.dump(metadata, f, ensure_ascii=False, indent=2)
    
    return metadata
```

### 3. 视频生成流程整合

现在，让我们修改您的 `concat_videos` 函数，并创建一个完整的视频生成流程：

```python:d:\14730\Desktop\GitProject\testiflow-studio\testiflow-studio-server\src\video_generator\contact_video.py
import ffmpeg
from typing import List, Optional
import os
import sys

# 添加项目根目录到系统路径
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))

from src.audio_generator.tts_generator import tts_generate
from src.media_search.keyword_extractor import extract_keywords, search_media_by_keywords

def concat_videos(video_paths: List[str], output_path: str = "output_dynamic.mp4") -> str:
    """
    将多个视频拼接为一个输出视频。

    参数：
        video_paths (List[str]): 待拼接视频的路径列表
        output_path (str): 输出视频路径（默认 output_dynamic.mp4）

    返回：
        str: 最终输出的视频文件路径
    """
    try:
        # 加载视频和音频流
        inputs = [ffmpeg.input(p) for p in video_paths]
        videos = [i.video.filter('scale', 1920, 1080).filter('fps', fps=30) for i in inputs]
        audios = [i.audio for i in inputs]

        # 拼接视频和音频
        concated = ffmpeg.concat(*[val for pair in zip(videos, audios) for val in pair], v=1, a=1)
        out = concated.output(output_path)

        # 执行合成
        out.run(overwrite_output=True, quiet=True)
        print(f"拼接成功，输出文件为 {output_path}")
        return os.path.abspath(output_path)

    except ffmpeg.Error as e:
        print("FFmpeg 出错了：")
        print(e.stderr.decode('utf8'))
        raise

def add_audio_to_video(video_path: str, audio_path: str, output_path: str = "final_video.mp4") -> str:
    """
    将音频添加到视频中
    
    参数：
        video_path (str): 视频文件路径
        audio_path (str): 音频文件路径
        output_path (str): 输出文件路径
        
    返回：
        str: 最终输出的视频文件路径
    """
    try:
        # 获取视频时长
        probe = ffmpeg.probe(video_path)
        video_duration = float(probe['format']['duration'])
        
        # 获取音频时长
        probe = ffmpeg.probe(audio_path)
        audio_duration = float(probe['format']['duration'])
        
        # 加载视频和音频
        video = ffmpeg.input(video_path)
        audio = ffmpeg.input(audio_path)
        
        # 如果音频比视频长，裁剪音频
        if audio_duration > video_duration:
            audio = audio.filter('atrim', duration=video_duration)
        
        # 如果视频比音频长，循环音频或者调整视频速度
        # 这里选择调整视频速度以匹配音频
        if video_duration > audio_duration:
            speed_factor = video_duration / audio_duration
            video = video.filter('setpts', f'{1/speed_factor}*PTS')
        
        # 合并视频和音频
        out = ffmpeg.output(
            video.video, 
            audio.audio, 
            output_path,
            vcodec='libx264',
            acodec='aac',
            strict='experimental'
        )
        
        # 执行合成
        out.run(overwrite_output=True, quiet=True)
        print(f"音视频合成成功，输出文件为 {output_path}")
        return os.path.abspath(output_path)
        
    except ffmpeg.Error as e:
        print("FFmpeg 出错了：")
        print(e.stderr.decode('utf8'))
        raise

def generate_video_from_script(
    script: str, 
    narration: str, 
    output_dir: str = "output",
    final_output: str = "final_video.mp4"
) -> str:
    """
    根据脚本和旁白生成完整视频
    
    参数：
        script (str): 视频脚本（用于提取关键词和检索视频素材）
        narration (str): 旁白文案（用于生成语音）
        output_dir (str): 输出目录
        final_output (str): 最终输出文件名
        
    返回：
        str: 最终生成的视频文件路径
    """
    # 创建输出目录
    os.makedirs(output_dir, exist_ok=True)
    
    # 1. 生成语音
    audio_path = os.path.join(output_dir, "narration.mp3")
    audio_path = tts_generate(narration, audio_path)
    
    # 2. 提取关键词
    keywords = extract_keywords(script, top_n=10)
    print(f"提取的关键词: {', '.join(keywords)}")
    
    # 3. 检索媒资
    video_paths = search_media_by_keywords(keywords)
    if not video_paths:
        raise ValueError("未找到匹配的视频素材")
    print(f"找到 {len(video_paths)} 个匹配的视频素材")
    
    # 4. 拼接视频
    concat_output = os.path.join(output_dir, "concat_video.mp4")
    concat_video_path = concat_videos(video_paths, concat_output)
    
    # 5. 合成音频和视频
    final_path = os.path.join(output_dir, final_output)
    final_video_path = add_audio_to_video(concat_video_path, audio_path, final_path)
    
    return final_video_path

# 示例用法
if __name__ == "__main__":
    script = """
    这是一个关于自然风景的视频。
    我们将看到美丽的山脉、湖泊和森林。
    大自然的美景令人心旷神怡。
    """
    
    narration = """
    欢迎观看这段自然风景视频。
    大自然的美丽令人叹为观止。
    请欣赏这些壮观的山脉、平静的湖泊和茂密的森林。
    感谢您的观看！
    """
    
    try:
        final_video = generate_video_from_script(script, narration)
        print(f"视频生成完成: {final_video}")
    except Exception as e:
        print(f"视频生成失败: {str(e)}")
```

## 实施步骤

1. 首先，您需要安装必要的依赖：

```bash
pip install ffmpeg-python edge-tts jieba
```

2. 创建媒资库目录结构：

```
media_library/
├── 自然/
│   ├── 山脉/
│   │   └── 雪山.mp4
│   ├── 湖泊/
│   │   └── 平静湖面.mp4
│   └── 森林/
│       └── 茂密森林.mp4
├── 城市/
│   └── ...
└── default/
    └── 默认视频.mp4
```

3. 运行示例代码测试整个流程

## 进一步优化建议

1. **媒资管理系统**：开发一个更完善的媒资管理系统，支持标签、分类和搜索功能。

2. **视频分析**：使用计算机视觉技术自动分析视频内容，提取关键帧和场景，更精准地匹配脚本需求。

3. **语音合成优化**：支持多种语音角色和情感表达，使旁白更加生动。

4. **视频转场效果**：在视频拼接时添加平滑的转场效果，提升视觉体验。

5. **Web界面**：开发一个用户友好的Web界面，让用户可以上传脚本、预览和下载生成的视频。

希望这个方案对您有所帮助！如果您有任何问题或需要进一步的帮助，请随时告诉我。